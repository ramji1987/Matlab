Copyright:Yaser Abu-Mostafa 

Feasibility of Learning
Consider a Boolean target function over a 3-dimensional input space X = f0; 1g3(instead of our 1 binary convention, we use 0,1 here since it is standard for Boolean
functions). We are given a data set D of ve examples represented in the table below,where yn = f(xn) for n = 1; 2; 3; 4; 5.
xn yn
0 0 0 0
0 0 1 1
0 1 0 1
0 1 1 0
1 0 0 1
Note that in this simple Boolean case, we can enumerate the entire input space (since there are only 23 = 8 distinct input vectors), and we can enumerate the set of allpossible target functions (there are only 223 = 256 distinct Boolean function on 3 Boolean inputs).
Let us look at the problem of learning f. Since f is unknown except inside D, any function that agrees with D could conceivably be f. Since there are only 3 points in
X outside D, there are only 23 = 8 such functions.The remaining points in X which are not in D are: 101, 110, and 111. We want to determine the hypothesis that agrees the most with the possible target functions. In order to quantify this, count how many of the 8 possible target functions agree with each hypothesis on all 3 points, how many agree on just 2 of the points, on just 1 point, and how many do not agree on any points. The nal score for each hypothesis
is computed as follows:
Score = (# of target functions agreeing with hypothesis on all 3 points)3 + (#
of target functions agreeing with hypothesis on exactly 2 points)2 + (# of target
functions agreeing with hypothesis on exactly 1 point)1 + (# of target functions
agreeing with hypothesis on 0 points)0.
6. Which hypothesis g agrees the most with the possible target functions in terms
of the above score?
[a] g returns 1 for all three points.
[b] g returns 0 for all three points.
[c] g is the XOR function applied to x, i.e., if the number of 1s in x is odd, g
returns 1; if it is even, g returns 0.
[d] g returns the opposite of the XOR function: if the number of 1s is odd, it
returns 0, otherwise returns 1.
[e] They are all equivalent (equal scores for g in [a] through [d]). 

Solution: 
function op = classify_x2aligned(X,slope,c)
x1 = ((X(2) - c) / slope);
if(X(1) > x1) 
    op = +1;
else
    op = -1;
end
return;
